package njusoftware.noComment.SamurAI.base;

public abstract class ConstVar {
	public static final int[] ACTION_ORDER = new int[] { 0, 3, 4, 1, 2, 5, 3, 0, 1, 4, 5, 2 }; // 行动的顺序，数字是samurais的下标
	public static final int CAPTURE_POW = 3, RISK_POW = 1, POSITION_POW = 1;
	// 用于推测位置的参数
	public static final int NEW_CAPTURE_POW = 2, // 新增占领区位置权重
			NEW_SUR_POW = 3, // 新增占领区周围权重
			PREV_POS_POW = 4, // 先前位置权重
			POS_SUR_POW = 4, // 先前位置周围的权重
			DEFAULT_MOV_RANGE_POW = 4;
	// 用于遍历周围格子的数组
	public static final int[][] SURROUNDINGS = { { -1, -1 }, { -1, 0 }, { -1, 1 }, { 0, 1 }, { 1, 1 }, { 1, 0 },
			{ 1, -1 }, { 0, -1 } };
	// 移动范围
	public static final int[][] MOVE_RANGE = { { 1, 0 }, { 2, 0 }, { 3, 0 }, { 0, 1 }, { 1, 1 }, { 2, 1 }, { 0, 2 },
			{ 1, 2 }, { 0, 3 }, { -1, 0 }, { -2, 0 }, { -3, 0 }, { -1, 1 }, { -2, 1 }, { -1, 2 }, { 0, -1 }, { 0, -2 },
			{ 0, -3 }, { 1, -1 }, { 1, -2 }, { 2, -1 }, { -1, -1 }, { -2, -1 }, { -1, -2 }, }; // 只移动的范围
	// 分成四块的移动范围
	public static final int[][][] SEPERATED_MOVE_RANGE = { // 注意坐标轴方向
			{ { 1, 0 }, { 2, 0 }, { 3, 0 }, { 1, 1 }, { 2, 1 }, { 1, 2 }, { 0, 1 }, { 0, 2 }, { 0, 3 }, }, // 第一象限,0
			{ { 0, 1 }, { 0, 2 }, { 0, 3 }, { -1, 1 }, { -2, 1 }, { -1, 2 }, { -1, 0 }, { -2, 0 }, { -3, 0 }, }, // 第二象限,1
			{ { -1, 0 }, { -2, 0 }, { -3, 0 }, { -1, -1 }, { -2, -1 }, { -1, -2 }, { 0, -1 }, { 0, -2 }, { 0, -3 }, }, // 第三象限,2
			{ { 0, -1 }, { 0, -2 }, { 0, -3 }, { 1, -1 }, { 2, -1 }, { 1, -2 }, { 1, 0 }, { 2, 0 }, { 3, 0 }, }, };// 第四象限,3
	// 由预测的不准确性导致的位置的可能偏移量，假定在曼哈顿距离2以内
	private static final int[][] POTENTIAL_POS = { { 0, -2 }, { 0, 2 }, { 2, 0 }, { -2, 0 }, { -1, 1 }, { -1, -1 },
			{ 1, -1 }, { 1, 1 }, { 0, -1 }, { 0, 1 }, { -1, 0 }, { 1, 0 }, { 0, 0 }, };
	// 按曼哈顿距离划分的放格
	private static final int[][][] MANHATTAN_DISTANCE = { { { 0, 1 }, { 0, -1 }, { 1, 0 }, { -1, 0 }, }, // 1
			{ { 0, 2 }, { 2, 0 }, { 0, -2 }, { -2, 0 }, { 1, 1 }, { 1, -1 }, { -1, -1 }, { -1, 1 }, }, // 2
			{ { 0, 3 }, { 3, 0 }, { 0, -3 }, { -3, 0 }, { 1, 2 }, { 2, -1 }, { -1, -2 }, { -2, 1 }, { 2, 1 }, { 1, -2 },
					{ -2, -1 }, { -1, 2 }, }, // 3
			{ { 0, 4 }, { 4, 0 }, { 0, -4 }, { -4, 0 }, { 1, 3 }, { 3, -1 }, { -1, -3 }, { -3, 1 }, { 2, 2 }, { 2, -2 },
					{ -2, -2 }, { -2, 2 }, { 3, 1 }, { 1, -3 }, { -3, -1 }, { -1, 3 }, }, // 4
			{ { 0, 5 }, { 5, 0 }, { 0, -5 }, { -5, 0 }, { 1, 4 }, { 4, -1 }, { -1, -4 }, { -4, 1 }, { 2, 3 }, { 3, -2 },
					{ -2, -3 }, { -3, 2 }, { 3, 2 }, { 2, -3 }, { -3, -2 }, { -2, 3 }, { 4, 1 }, { 1, -4 }, { -4, -1 },
					{ -1, 4 }, }, // 5
			{ { 0, 6 }, { 6, 0 }, { 0, -6 }, { -6, 0 }, { 1, 5 }, { 5, -1 }, { -1, -5 }, { -5, 1 }, { 2, 4 }, { 4, -2 },
					{ -2, -4 }, { -4, 2 }, { 3, 3 }, { 3, -3 }, { -3, -3 }, { -3, 3 }, { 4, 2 }, { 2, -4 }, { -4, -2 },
					{ -2, 4 }, { 5, 1 }, { 1, -5 }, { -5, -1 }, { -1, 5 }, }, // 6
			{ { 0, 7 }, { 7, 0 }, { 0, -7 }, { -7, 0 }, { 1, 6 }, { 6, -1 }, { -1, -6 }, { -6, 1 }, { 2, 5 }, { 5, -2 },
					{ -2, -5 }, { -5, 2 }, { 3, 4 }, { 4, -3 }, { -3, -4 }, { -4, 3 }, { 4, 3 }, { 3, -4 }, { -4, -3 },
					{ -3, 4 }, { 5, 2 }, { 2, -5 }, { -5, -2 }, { -2, 5 }, { 6, 1 }, { 1, -6 }, { -6, -1 },
					{ -1, 6 }, } };// 7

	public static final int[][] getPotentialPos(final int[] centralPos) {
		int[][] result = new int[13][2];
		for (int i = 0; i < 13; i++) {
			result[i][0] = centralPos[0] + POTENTIAL_POS[i][0];
			result[i][1] = centralPos[1] + POTENTIAL_POS[i][1];
		}
		return result;
	}

	public static final int[][] manhattanDistance(int distance) {
		return MANHATTAN_DISTANCE[distance - 1];
	}
}
